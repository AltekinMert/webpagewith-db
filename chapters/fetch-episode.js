const episodesYzk = [
    { name: 'YZK 1.Bölüm', file: 'yzk/yzk-1.docx' },
    { name: 'YZK 2.Bölüm', file: 'yzk/yzk-2.docx' },
    { name: 'YZK 3.Bölüm', file: 'yzk/yzk-3.docx' },
    { name: 'YZK 4.Bölüm', file: 'yzk/yzk-4.docx' },
    { name: 'YZK 5.Bölüm', file: 'yzk/yzk-5.docx' },
    { name: 'YZK 6.Bölüm', file: 'yzk/yzk-6.docx' },
    { name: 'YZK 7.Bölüm', file: 'yzk/yzk-7.docx' },
    { name: 'YZK 8.Bölüm', file: 'yzk/yzk-8.docx' },
    { name: 'YZK 9.Bölüm', file: 'yzk/yzk-9.docx' },
    { name: 'YZK 10.Bölüm', file: 'yzk/yzk-10.docx' },
    { name: 'YZK 11.Bölüm', file: 'yzk/yzk-11.docx' },
    { name: 'YZK 12.Bölüm', file: 'yzk/yzk-12.docx' },
    { name: 'YZK 13.Bölüm', file: 'yzk/yzk-13.docx' },
    { name: 'YZK 14.Bölüm', file: 'yzk/yzk-14.docx' },
    { name: 'YZK 15.Bölüm', file: 'yzk/yzk-15.docx' },
    { name: 'YZK 16.Bölüm', file: 'yzk/yzk-16.docx' },
    { name: 'YZK 17.Bölüm', file: 'yzk/yzk-17.docx' },
    { name: 'YZK 18.Bölüm', file: 'yzk/yzk-18.docx' },
    { name: 'YZK 19.Bölüm', file: 'yzk/yzk-19.docx' },
    { name: 'YZK 20.Bölüm', file: 'yzk/yzk-20.docx' },
    { name: 'YZK 21.Bölüm', file: 'yzk/yzk-21.docx' },
    { name: 'YZK 22.Bölüm', file: 'yzk/yzk-22.docx' },
    { name: 'YZK 23.Bölüm', file: 'yzk/yzk-23.docx' },
    { name: 'YZK 24.Bölüm', file: 'yzk/yzk-24.docx' },
    { name: 'YZK 25.Bölüm', file: 'yzk/yzk-25.docx' },
  ];
  const episodesLeza = [
    { name: 'Leza 1.Bölüm', file: 'Leza/leza-1.docx' },
    { name: 'Leza 2.Bölüm', file: 'Leza/leza-2.docx' },
    { name: 'Leza 3.Bölüm', file: 'Leza/leza-3.docx' },
    { name: 'Leza 4.Bölüm', file: 'Leza/leza-4.docx' },
    { name: 'Leza 5.Bölüm', file: 'Leza/leza-5.docx' },
    { name: 'Leza 6.Bölüm', file: 'Leza/leza-6.docx' },
    { name: 'Leza 7.Bölüm', file: 'Leza/leza-7.docx' },
    { name: 'Leza 8.Bölüm', file: 'Leza/leza-8.docx' },
    { name: 'Leza 9.Bölüm', file: 'Leza/leza-9.docx' },
    { name: 'Leza 10.Bölüm', file: 'Leza/leza-10.docx' },
    { name: 'Leza 11.Bölüm', file: 'Leza/leza-11.docx' },
    { name: 'Leza 12.Bölüm', file: 'Leza/leza-12.docx' },
    { name: 'Leza 13.Bölüm', file: 'Leza/leza-13.docx' },
    { name: 'Leza 14.Bölüm', file: 'Leza/leza-14.docx' },
    { name: 'Leza 15.Bölüm', file: 'Leza/leza-15.docx' },
    { name: 'Leza 16.Bölüm', file: 'Leza/leza-16.docx' },
    { name: 'Leza 17.Bölüm', file: 'Leza/leza-17.docx' },
    { name: 'Leza 18.Bölüm', file: 'Leza/leza-18.docx' },
    { name: 'Leza 19.Bölüm', file: 'Leza/leza-19.docx' },
    { name: 'Leza 20.Bölüm', file: 'Leza/leza-20.docx' },
    { name: 'Leza 21.Bölüm', file: 'Leza/leza-21.docx' },
    { name: 'Leza 22.Bölüm', file: 'Leza/leza-22.docx' },
    { name: 'Leza 23.Bölüm', file: 'Leza/leza-23.docx' },
    { name: 'Leza 24.Bölüm', file: 'Leza/leza-24.docx' },
    { name: 'Leza 25.Bölüm', file: 'Leza/leza-25.docx' },
    { name: 'Leza 26.Bölüm', file: 'Leza/leza-26.docx' },
    { name: 'Leza 27.Bölüm', file: 'Leza/leza-27.docx' },
    { name: 'Leza 28.Bölüm', file: 'Leza/leza-28.docx' },
    { name: 'Leza 29.Bölüm', file: 'Leza/leza-29.docx' },
    { name: 'Leza 30.Bölüm', file: 'Leza/leza-30.docx' },
    { name: 'Leza 31.Bölüm', file: 'Leza/leza-31.docx' },
    { name: 'Leza 32.Bölüm', file: 'Leza/leza-32.docx' },
    { name: 'Leza 33.Bölüm', file: 'Leza/leza-33.docx' },
    { name: 'Leza 34.Bölüm', file: 'Leza/leza-34.docx' },
    { name: 'Leza 35.Bölüm', file: 'Leza/leza-35.docx' },
    { name: 'Leza 36.Bölüm', file: 'Leza/leza-36.docx' },
    { name: 'Leza 37.Bölüm', file: 'Leza/leza-37.docx' },
    { name: 'Leza 38.Bölüm', file: 'Leza/leza-38.docx' },
    { name: 'Leza 39.Bölüm', file: 'Leza/leza-39.docx' },
    { name: 'Leza 40.Bölüm', file: 'Leza/leza-40.docx' },
    { name: 'Leza 41.Bölüm', file: 'Leza/leza-41.docx' },
    { name: 'Leza 42.Bölüm', file: 'Leza/leza-42.docx' },
];
const episodesValens = [
  { name: 'Valens 1.Bölüm', file: 'valens/valens-1.docx' },
  { name: 'Valens 2.Bölüm', file: 'valens/valens-2.docx' },
  { name: 'Valens 3.Bölüm', file: 'valens/valens-3.docx' },
  { name: 'Valens 4.Bölüm', file: 'valens/valens-4.docx' },
  { name: 'Valens 5.Bölüm', file: 'valens/valens-5.docx' },
  { name: 'Valens 6.Bölüm', file: 'valens/valens-6.docx' },
  { name: 'Valens 7.Bölüm', file: 'valens/valens-7.docx' },
  { name: 'Valens 8.Bölüm', file: 'valens/valens-8.docx' },
  { name: 'Valens 9.Bölüm', file: 'valens/valens-9.docx' },
  { name: 'Valens 10.Bölüm', file: 'valens/valens-10.docx' },
  { name: 'Valens 11.Bölüm', file: 'valens/valens-11.docx' },
  { name: 'Valens 12.Bölüm', file: 'valens/valens-12.docx' },
  { name: 'Valens 13.Bölüm', file: 'valens/valens-13.docx' },
  { name: 'Valens 14.Bölüm', file: 'valens/valens-14.docx' },
  { name: 'Valens 15.Bölüm', file: 'valens/valens-15.docx' },
  { name: 'Valens 16.Bölüm', file: 'valens/valens-16.docx' },
  { name: 'Valens 17.Bölüm', file: 'valens/valens-17.docx' },
  { name: 'Valens 18.Bölüm', file: 'valens/valens-18.docx' },
  { name: 'Valens 19.Bölüm', file: 'valens/valens-19.docx' },
  { name: 'Valens 20.Bölüm', file: 'valens/valens-20.docx' },
  { name: 'Valens 21.Bölüm', file: 'valens/valens-21.docx' },
  { name: 'Valens 22.Bölüm', file: 'valens/valens-22.docx' },
  { name: 'Valens 23.Bölüm', file: 'valens/valens-23.docx' },
  { name: 'Valens 24.Bölüm', file: 'valens/valens-24.docx' },
  { name: 'Valens 25.Bölüm', file: 'valens/valens-25.docx' },
  { name: 'Valens 26.Bölüm', file: 'valens/valens-26.docx' },
  { name: 'Valens 27.Bölüm', file: 'valens/valens-27.docx' },
  { name: 'Valens 28.Bölüm', file: 'valens/valens-28.docx' },
  { name: 'Valens 29.Bölüm', file: 'valens/valens-29.docx' },
  { name: 'Valens 30.Bölüm', file: 'valens/valens-30.docx' },
  { name: 'Valens 31.Bölüm', file: 'valens/valens-31.docx' },
  { name: 'Valens 32.Bölüm', file: 'valens/valens-32.docx' },
  { name: 'Valens 33.Bölüm', file: 'valens/valens-33.docx' },
  { name: 'Valens 34.Bölüm', file: 'valens/valens-34.docx' },
  { name: 'Valens 35.Bölüm', file: 'valens/valens-35.docx' },
  { name: 'Valens 36.Bölüm', file: 'valens/valens-36.docx' },
  { name: 'Valens 37.Bölüm', file: 'valens/valens-37.docx' },
  { name: 'Valens 38.Bölüm', file: 'valens/valens-38.docx' },
  { name: 'Valens 39.Bölüm', file: 'valens/valens-39.docx' },
  { name: 'Valens 40.Bölüm', file: 'valens/valens-40.docx' },
  { name: 'Valens 41.Bölüm', file: 'valens/valens-41.docx' },
  { name: 'Valens 42.Bölüm', file: 'valens/valens-42.docx' },
];
const episodesMabel = [
  { name: 'Mabel 1.Bölüm', file: 'mabel/mabel-1.docx' },
  { name: 'Mabel 2.Bölüm', file: 'mabel/mabel-2.docx' },
  { name: 'Mabel 3.Bölüm', file: 'mabel/mabel-3.docx' },
  { name: 'Mabel 4.Bölüm', file: 'mabel/mabel-4.docx' },
  { name: 'Mabel 5.Bölüm', file: 'mabel/mabel-5.docx' },
  { name: 'Mabel 6.Bölüm', file: 'mabel/mabel-6.docx' },
  { name: 'Mabel 7.Bölüm', file: 'mabel/mabel-7.docx' },
  { name: 'Mabel 8.Bölüm', file: 'mabel/mabel-8.docx' },
  { name: 'Mabel 9.Bölüm', file: 'mabel/mabel-9.docx' },
  { name: 'Mabel 10.Bölüm', file: 'mabel/mabel-10.docx' },
  { name: 'Mabel 11.Bölüm', file: 'mabel/mabel-11.docx' },
  { name: 'Mabel 12.Bölüm', file: 'mabel/mabel-12.docx' },
  { name: 'Mabel 13.Bölüm', file: 'mabel/mabel-13.docx' },
  { name: 'Mabel 14.Bölüm', file: 'mabel/mabel-14.docx' },
  { name: 'Mabel 15.Bölüm', file: 'mabel/mabel-15.docx' },
  { name: 'Mabel 16.Bölüm', file: 'mabel/mabel-16.docx' },
  { name: 'Mabel 17.Bölüm', file: 'mabel/mabel-17.docx' },
  { name: 'Mabel 18.Bölüm', file: 'mabel/mabel-18.docx' },
  { name: 'Mabel 19.Bölüm', file: 'mabel/mabel-19.docx' },
  { name: 'Mabel 20.Bölüm', file: 'mabel/mabel-20.docx' },
  { name: 'Mabel 21.Bölüm', file: 'mabel/mabel-21.docx' },
  { name: 'Mabel 22.Bölüm', file: 'mabel/mabel-22.docx' },
  { name: 'Mabel 23.Bölüm', file: 'mabel/mabel-23.docx' },
  { name: 'Mabel 24.Bölüm', file: 'mabel/mabel-24.docx' },
  { name: 'Mabel 25.Bölüm', file: 'mabel/mabel-25.docx' },
  { name: 'Mabel 26.Bölüm', file: 'mabel/mabel-26.docx' },
  { name: 'Mabel 27.Bölüm', file: 'mabel/mabel-27.docx' },
  { name: 'Mabel 28.Bölüm', file: 'mabel/mabel-28.docx' },
  { name: 'Mabel 29.Bölüm', file: 'mabel/mabel-29.docx' },
];

const episodesSonunBaslangici = [
  { name: 'Sonun Başlangıcı 1.Bölüm', file: 'sonun-başlangıcı/sonun-başlangıcı-1.docx' },
  { name: 'Sonun Başlangıcı 2.Bölüm', file: 'sonun-başlangıcı/sonun-başlangıcı-2.docx' },
];
const episodesDerinSular = [
  { name: 'Derin Sular 1.Bölüm', file: 'derin-sular/derin-sular-1.docx' },
  { name: 'Derin Sular 2.Bölüm', file: 'derin-sular/derin-sular-2.docx' },
  { name: 'Derin Sular 3.Bölüm', file: 'derin-sular/derin-sular-3.docx' },
  { name: 'Derin Sular 4.Bölüm', file: 'derin-sular/derin-sular-4.docx' },
  { name: 'Derin Sular 5.Bölüm', file: 'derin-sular/derin-sular-5.docx' },
];

  
 // References to elements
 let commentsCache = {}; // Cache to store preloaded comments for the current episode
const customDropdown = document.getElementById('customDropdown');
const dropdownSelect = customDropdown.querySelector('.dropdown-select');
const selectedOption = customDropdown.querySelector('.selected-option');
const episodeName = customDropdown.querySelector('.episode-name');
const optionsList = document.getElementById('optionsList');
const prevButton = document.getElementById('prevButton');
const nextButton = document.getElementById('nextButton');
const nextButton2 = document.querySelector('.next-episode');

const arrowIcon = dropdownSelect.querySelector('.arrow i');

let currentIndex = 0; // Set to 0 to select the first episode by default
let isFirstLoad = true; // Flag to prevent scrolling on first load
let globalEpisodeTitle = '';  // Store episode name globally

// Extract book name from current HTML file name
function getBookNameFromURL() {
  const pathArray = window.location.pathname.split('/');
  const fileName = pathArray[pathArray.length - 1];  // Get file name (e.g., yzk.html)
  const bookName = fileName.replace('.html', '');   // Remove .html to get book name
  return bookName.charAt(0).toUpperCase() + bookName.slice(1);  // Capitalize
}

const currentBook = getBookNameFromURL();
console.log('Current Book:', currentBook);  // For debugging
let episodes;
switch (currentBook.toLowerCase()) {
  case 'yzk':
      episodes = episodesYzk;
      break;
  case 'leza':
      episodes = episodesLeza;
      break;
  case 'mabel':
      episodes = episodesMabel;
      break;
  case 'sonun-baslangici':
      episodes = episodesSonunBaslangici;
      break;
  case 'derin-sular':
      episodes = episodesDerinSular;
      break;
  case 'valens':
      episodes = episodesValens;
      break;
  default:
      episodes = []; // or handle the case where no match is found
}
import {
  ref,
  push,
  get,
  child,
  onValue,
  getDatabase,
} from "https://www.gstatic.com/firebasejs/11.1.0/firebase-database.js";
import { db } from "./firebase-config.js"; // Import your initialized Firebase database


// Populate the options list
episodes.forEach((episode, index) => {
  const optionDiv = document.createElement('div');
  optionDiv.classList.add('option');
  optionDiv.textContent = episode.name;
  optionDiv.dataset.file = episode.file; // Store the filename for later use
  optionDiv.dataset.index = index; // Store the index for easy navigation
  optionsList.appendChild(optionDiv);
});

// Automatically select the first episode when the page loads
updateSelectedOption();

// Toggle dropdown visibility
dropdownSelect.addEventListener('click', () => {
  const isOpen = optionsList.style.display === 'block';
  optionsList.style.display = isOpen ? 'none' : 'block';
  arrowIcon.classList.toggle('fa-angle-down', isOpen);
  arrowIcon.classList.toggle('fa-angle-up', !isOpen);
});

// Handle option selection
optionsList.addEventListener('click', (event) => {
  const clickedOption = event.target;
  if (clickedOption.classList.contains('option')) {
    const previousSelected = optionsList.querySelector('.option.selected');
    if (previousSelected) {
      previousSelected.classList.remove('selected');
    }
    clickedOption.classList.add('selected');
    currentIndex = parseInt(clickedOption.dataset.index);
    episodeName.textContent = clickedOption.textContent;
    optionsList.style.display = 'none';
    arrowIcon.classList.remove('fa-angle-up');
    arrowIcon.classList.add('fa-angle-down');
    loadDocument(clickedOption.dataset.file);
    scrollToContentTop();
    updateSelectedOption();
  }
});

document.addEventListener('click', (event) => {
  if (!customDropdown.contains(event.target)) {
    optionsList.style.display = 'none';
    arrowIcon.classList.remove('fa-angle-up');
    arrowIcon.classList.add('fa-angle-down');
  }
});

// Event listeners for Previous and Next buttons
prevButton.addEventListener('click', () => {
  if (currentIndex > 0) {
    currentIndex--;
    updateSelectedOption();
  }
});
nextButton.addEventListener('click', () => {
  if (currentIndex < episodes.length - 1) {
    currentIndex++;
    updateSelectedOption();
  }
});
nextButton2.addEventListener('click', () => {
  if (currentIndex < episodes.length - 1) {
    currentIndex++;
    updateSelectedOption();
  }
});

// Function to update the selected option and load the document
// Function to load the selected document
function loadDocument(filename, episodeId) {
  const contentDiv = document.getElementById('content');
  contentDiv.innerHTML = ''; // Clear previous content

  if (filename) {
    const fileExtension = filename.split('.').pop().toLowerCase();
    const filePath = `chapters/${filename}`;

    if (fileExtension === 'pdf') {
      loadPDF(filePath);
    } else if (fileExtension === 'docx') {
      loadDOCX(filePath, episodeId);
    }
  }
}

function loadDOCX(url, episodeId) {
  const contentDiv = document.getElementById('content');
  contentDiv.innerHTML = 'Bölüm Yükleniyor...';

  fetch(url)
    .then((response) => response.arrayBuffer())
    .then((arrayBuffer) => {
      return mammoth.convertToHtml({ arrayBuffer });
    })
    .then((result) => {
      contentDiv.innerHTML = ''; // Clear loading message

      // Split the content into lines or paragraphs
      const paragraphs = result.value.split(/<\/p>\s*<p>/); // Use simple split logic for separating <p> tags

      paragraphs.forEach((paragraphContent, index) => {
        const paragraphContainer = document.createElement('div');
        paragraphContainer.classList.add('paragraph-container');
        paragraphContainer.dataset.index = index;

        // Add paragraph text
        const p = document.createElement('p');
        p.innerHTML = paragraphContent.replace(/<\/?p>/g, '').trim(); // Clean up <p> tags
        paragraphContainer.appendChild(p);


        // Capture episode title from first paragraph (data-index=0)
        if (index === 0) {
          globalEpisodeTitle = p.textContent;  // Store the first paragraph globally
        }

        // Add Comment Button with Font Awesome icon and counter
        const commentButton = document.createElement('button');
        commentButton.classList.add('comment-button');
        const commentCount = commentsCache[index]?.length || 0;

        if(commentCount > 0){
          commentButton.innerHTML = `
          <i class="fa-solid fa-message"></i>
          <span class="comment-count">${commentCount}</span>
        `;
        } else {
          commentButton.innerHTML = `
          <i class="fa-solid fa-message"></i>
          <span class="comment-count">
          <i class="fa-solid fa-plus"></i>
          </span>
        `;
        }
        commentButton.addEventListener('click', () => {
          showCommentBox(index, episodeId, paragraphContainer);
        });
        paragraphContainer.appendChild(commentButton);

        // Append paragraph container to the content div
        contentDiv.appendChild(paragraphContainer);
      });
    })
    .catch((error) => {
      console.error('Error loading DOCX:', error);
      contentDiv.innerHTML = 'Bölüm Yüklenirken Hata Oluştu Lütfen Hatayı Bizlerle Paylaşınız';
    });
}






// Function to show the comment box

function showCommentBox(paragraphIndex, episodeId, container) {

  document.querySelector('#commentModal')?.remove();
  document.querySelector('#modalOverlay')?.remove();

  // Check if a modal already exists
  let existingModal = document.querySelector('#commentModal');
  if (existingModal) {
    existingModal.remove(); // Remove any existing modals
  }


   // Create the overlay (dark background)
   const overlay = document.createElement('div');
   overlay.id = 'modalOverlay';
   overlay.classList.add('modal-overlay');
   document.body.appendChild(overlay);



  const paragraphText = container.querySelector('p').innerHTML;
  // Create the modal container
  const modal = document.createElement('div');
  modal.id = 'commentModal';
  modal.classList.add('comment-modal');

  const kitapOkuDiv = document.querySelector('.kitap-oku');
  if (kitapOkuDiv && kitapOkuDiv.classList.contains('dark-mode')) {
    modal.classList.add('dark-mode'); // Add dark-mode class to the modal
  }

  // Create modal content
  const modalContent = document.createElement('div');
  modalContent.id = 'modalContent';
  modalContent.classList.add('modal-content');

  // Close button for modal
  const closeButton = document.createElement('span');
  closeButton.id = 'closeButton';
  closeButton.classList.add('close-button');
  closeButton.textContent = '×';
   closeButton.addEventListener('click', () => {
    modal.remove();  // Remove modal
    overlay.remove();  // Remove overlay when closing the modal
  });
  //kitap baslik
  const bookTitle = document.createElement('h3');
  bookTitle.id = 'bookTitle';
  bookTitle.textContent = globalEpisodeTitle;

  // Title for comments section - Use paragraph content
  const modalTitle = document.createElement('h3');
  modalTitle.id = 'modalTitle';
  modalTitle.innerHTML = `${paragraphText}`;  // Set paragraph content as title

  // Comments display section
  const commentDisplay = document.createElement('div');
  commentDisplay.id = `commentDisplay-${paragraphIndex}`;
  commentDisplay.classList.add('comment-display-modal');

  // Load comments from cache
  const cachedComments = commentsCache[paragraphIndex] || [];
  cachedComments.forEach((comment) => {
    const commentDiv = document.createElement('div');
    const timeAgoText = timeAgo(comment.timestamp);
    const userDiv = document.createElement('div');
    userDiv.classList.add('user-icon');
    const otherDiv = document.createElement('div');
    otherDiv.classList.add('other-div');
    otherDiv.innerHTML=`
    <strong>${comment.username}</strong> <p>${comment.comment}</p>
    <span class="time-ago">${timeAgoText}</span>
  `;

    userDiv.innerHTML= '<i class="fa-solid fa-circle-user"></i>'
    commentDiv.innerHTML = `
    ${userDiv.outerHTML}
    ${otherDiv.outerHTML}
  `;
    commentDisplay.appendChild(commentDiv);
  });

  // Input for username
  const divforinput = document.createElement('div');
  divforinput.id = 'divforinput';

  const usernameInput = document.createElement('input');
  usernameInput.id = 'usernameInput';
  usernameInput.placeholder = ' Kullanıcı Adı';

  divforinput.appendChild(usernameInput);

  const commentInputContainer = document.createElement('div');
commentInputContainer.classList.add('comment-input-container');


  // Input for comment
  const textarea = document.createElement('textarea');
  textarea.id = 'commentTextarea';
  textarea.placeholder = 'Bir yorum yaz...';

  const submitButton = document.createElement('button');
submitButton.id = 'submitButton';

// Create the <i> element for the icon
const icon = document.createElement('i');
icon.className = 'fa-regular fa-paper-plane';  // FontAwesome icon class

// Append the icon to the button
submitButton.appendChild(icon);

// Add event listener (same as before)
submitButton.addEventListener('click', async () => {
    await saveComment(paragraphIndex, episodeId, usernameInput.value, textarea.value);
    // usernameInput.value = '';
    // textarea.value = '';

    // Update the modal with the new comment
    const newComment = {
      username: usernameInput.value,
      comment: textarea.value,
      time: "1sn önce",
    };
    const newCommentDiv = document.createElement('div');

    const userDiv = document.createElement('div');
    userDiv.classList.add('user-icon');

    const otherDiv = document.createElement('div');
    otherDiv.classList.add('other-div');

    otherDiv.innerHTML=`
    <strong>${newComment.username}</strong> <p>${newComment.comment}</p>
    <span class="time-ago">${newComment.time}</span>
  `;

    userDiv.innerHTML= '<i class="fa-solid fa-circle-user"></i>';

    newCommentDiv.innerHTML = `
    ${userDiv.outerHTML}
    ${otherDiv.outerHTML}
  `;
    commentDisplay.appendChild(newCommentDiv);
});


  commentInputContainer.appendChild(textarea);
  commentInputContainer.appendChild(submitButton);  

  // Append elements to modal content
  modalContent.appendChild(closeButton);
  modalContent.appendChild(bookTitle);
  modalContent.appendChild(modalTitle);
  modalContent.appendChild(commentDisplay);
  modalContent.appendChild(divforinput);
  // modalContent.appendChild(textarea);
  // modalContent.appendChild(submitButton);
  modalContent.appendChild(commentInputContainer);
  

  // Append modal content to modal container
  modal.appendChild(modalContent);

  // Append modal to the body
  document.body.appendChild(modal);
}

async function saveComment(paragraphIndex, episodeId, username, comment) {
  if (!username || !comment) {
    alert('Lütfen Kullanıcı Adı ve Yorum Bölümünü Doldurunuz');
    return;
  }

  const commentData = {
    username,
    comment,
    timestamp: new Date().toISOString(),
  };

  try {
    // Reference to the Firebase Realtime Database
    const commentsRef = ref(db, `comments/${currentBook}/${episodeId}/${paragraphIndex}`);

    // Push the new comment to Firebase
    await push(commentsRef, commentData);

    console.log('Comment saved for book:', currentBook);

    // Update commentsCache locally
    if (!commentsCache[paragraphIndex]) {
      commentsCache[paragraphIndex] = [];
    }
    // commentsCache[paragraphIndex].push(commentData);

    // Update the comment counter in the UI
    const button = document.querySelector(
      `.paragraph-container[data-index="${paragraphIndex}"] .comment-button`
    );
    if (button) {
      const countSpan = button.querySelector('.comment-count');
      const newCount = commentsCache[paragraphIndex].length;
      if (countSpan) {
        // countSpan.textContent = newCount; 
      }
    }

    // alert('Comment added successfully!');
  } catch (error) {
    console.error('Error saving comment to Firebase:', error);
    alert('An error occurred while saving your comment. Please try again.');
  }
}


function loadComments(paragraphIndex, episodeId, container) {
  const commentsRef = ref(db, `comments/${episodeId}/${paragraphIndex}`);

  // Listen to comments in real-time
  onValue(commentsRef, (snapshot) => {
    const comments = snapshot.val();
    container.innerHTML = ""; // Clear existing comments

    if (comments) {
      Object.values(comments).forEach((comment) => {
        const commentDiv = document.createElement("div");
        commentDiv.innerHTML = `<strong>${comment.username}:</strong> ${comment.comment}`;
        container.appendChild(commentDiv);
      });
    }
  });
}


// Update document loading with episode ID
function updateSelectedOption() {
  const episode = episodes[currentIndex];
  const previousSelected = optionsList.querySelector('.option.selected');
  if (previousSelected) {
    previousSelected.classList.remove('selected');
  }
  const newSelected = optionsList.querySelector(`.option[data-index="${currentIndex}"]`);
  if (newSelected) {
    newSelected.classList.add('selected');
  }
  episodeName.textContent = episode.name;

  // Prefetch comments for the selected episode
  // preloadCommentsForEpisode(currentIndex);

  loadDocument(episode.file, currentIndex); // Pass episode ID
  if (!isFirstLoad) {
    scrollToContentTop();
  } else {
    isFirstLoad = false;
  }
  preloadCommentsForEpisode(currentIndex);
}

async function preloadCommentsForEpisode(episodeId) {
  const commentsRef = ref(db, `comments/${currentBook}/${episodeId}`);

  onValue(commentsRef, (snapshot) => {
    const episodeComments = snapshot.val();
    commentsCache = {}; // Clear previous cache

    if (episodeComments) {
      Object.entries(episodeComments).forEach(([paragraphId, comments]) => {
        commentsCache[paragraphId] = Object.values(comments);
      });
    }
    
    // Update counters in buttons after cache is ready
    const contentDiv = document.getElementById("content");
    const buttons = contentDiv.querySelectorAll(".comment-button");
    buttons.forEach((button, index) => {
      const commentCount = commentsCache[index]?.length || 0;
      const countSpan = button.querySelector(".comment-count");
      if (countSpan) {
        if(commentCount > 0) {
          countSpan.textContent = commentCount; // Update the count dynamically
        } else {
          // Create the <i> element for the icon
          const icon = document.createElement('i');
          icon.className = 'fa-solid fa-plus';  // FontAwesome icon class
          countSpan.textContent= '';
          countSpan.appendChild(icon);
        }
      }
    });
  });
}






// Scroll to content top
function scrollToContentTop() {
  let content = document.querySelector('.playlist-class');
  if (content) {
    const contentTop = content.offsetTop + content.offsetHeight;
    window.scrollTo({
      top: contentTop,
      behavior: 'smooth',
    });
  } else {
    console.error('#content not found.');
  }
}

function timeAgo(dateString) {
  const now = new Date();
  const past = new Date(dateString);
  const diffInSeconds = Math.floor((now - past) / 1000);

  const intervals = {
    y: 31536000,
    ay: 2592000,
    hafta: 604800,
    gün: 86400,
    saat: 3600,
    dk: 60,
    sn: 1,
  };

  for (const [key, value] of Object.entries(intervals)) {
    const count = Math.floor(diffInSeconds / value);
    if (count > 0) {
      return `${count}${key} önce`;  // e.g., 2 ay önce, 1 yıl önce
    }
  }
  return "az önce";
}